package provider

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/provider"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/tidbcloud/terraform-provider-tidbcloud/tidbcloud"
	"strings"
)

type backupResourceData struct {
	ClusterId       string       `tfsdk:"cluster_id"`
	ProjectId       string       `tfsdk:"project_id"`
	Name            string       `tfsdk:"name"`
	Description     types.String `tfsdk:"description"`
	BackupId        types.String `tfsdk:"id"`
	Type            types.String `tfsdk:"type"`
	Size            types.String `tfsdk:"size"`
	Status          types.String `tfsdk:"status"`
	CreateTimestamp types.String `tfsdk:"create_timestamp"`
}

// Ensure provider defined types fully satisfy framework interfaces
var _ provider.ResourceType = backupResourceType{}
var _ resource.Resource = backupResource{}
var _ resource.ResourceWithImportState = backupResource{}

type backupResourceType struct{}

func (t backupResourceType) GetSchema(ctx context.Context) (tfsdk.Schema, diag.Diagnostics) {
	return tfsdk.Schema{
		MarkdownDescription: "backup resource",
		Attributes: map[string]tfsdk.Attribute{
			"project_id": {
				MarkdownDescription: "The ID of the project. You can get the project ID from [tidbcloud_project datasource](../project).",
				Required:            true,
				Type:                types.StringType,
			},
			"cluster_id": {
				Required:            true,
				MarkdownDescription: "The ID of your cluster that you want to take a manual backup.",
				Type:                types.StringType,
			},
			"name": {
				MarkdownDescription: "Specify the name for a manual backup. It is recommended that you use a unique name, so that it is easy to distinguish the backup when you query the backups.",
				Required:            true,
				Type:                types.StringType,
			},
			"description": {
				MarkdownDescription: "The description of the backup. It helps you add additional information to the backup. Allows up to 256 characters.",
				Optional:            true,
				Computed:            true,
				Type:                types.StringType,
			},
			"id": {
				Computed:            true,
				MarkdownDescription: "The ID of the backup. It is generated by TiDB Cloud.",
				Type:                types.StringType,
				PlanModifiers: tfsdk.AttributePlanModifiers{
					resource.UseStateForUnknown(),
				},
			},
			"type": {
				Computed:            true,
				MarkdownDescription: "Enum: MANUAL/AUTO.The type of backup. TiDB Cloud only supports manual and auto backup. For more information, see [TiDB Cloud Documentation](https://docs.pingcap.com/tidbcloud/backup-and-restore#backup).",
				Type:                types.StringType,
				PlanModifiers: tfsdk.AttributePlanModifiers{
					resource.UseStateForUnknown(),
				},
			},
			"size": {
				Computed:            true,
				MarkdownDescription: "The bytes of the backup.",
				Type:                types.StringType,
				PlanModifiers: tfsdk.AttributePlanModifiers{
					resource.UseStateForUnknown(),
				},
			},
			"status": {
				Computed:            true,
				MarkdownDescription: "Enum: PENDING/RUNNING/FAILED/SUCCESS.The status of backup.",
				Type:                types.StringType,
				PlanModifiers: tfsdk.AttributePlanModifiers{
					resource.UseStateForUnknown(),
				},
			},
			"create_timestamp": {
				Computed:            true,
				MarkdownDescription: "The creation time of the backup in UTC. The time format follows the ISO8601 standard, which is YYYY-MM-DD (year-month-day) + T +HH:MM:SS (hour-minutes-seconds) + Z. For example, 2020-01-01T00:00:00Z.",
				Type:                types.StringType,
				PlanModifiers: tfsdk.AttributePlanModifiers{
					resource.UseStateForUnknown(),
				},
			},
		},
	}, nil
}

func (t backupResourceType) NewResource(ctx context.Context, in provider.Provider) (resource.Resource, diag.Diagnostics) {
	provider, diags := convertProviderType(in)

	return backupResource{
		provider: provider,
	}, diags
}

type backupResource struct {
	provider tidbcloudProvider
}

func (r backupResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data backupResourceData
	diags := req.Config.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	createBackupReq := tidbcloud.CreateBackupReq{
		Name: data.Name,
	}
	if !data.Description.IsUnknown() && !data.Description.IsNull() {
		createBackupReq.Description = data.Description.Value
	}

	tflog.Trace(ctx, "created backup resource")
	createBackupResp, err := r.provider.client.CreateBackup(data.ProjectId, data.ClusterId, createBackupReq)
	if err != nil {
		resp.Diagnostics.AddError("Create Error", fmt.Sprintf("Unable to call create backup, got error: %s", err))
		return
	}

	tflog.Trace(ctx, "get backup resource")
	getBackupResp, err := r.provider.client.GetBackupById(data.ProjectId, data.ClusterId, createBackupResp.BackupId)
	if err != nil {
		resp.Diagnostics.AddError("Create Error", fmt.Sprintf("Unable to call GetBackupById, got error: %s", err))
		return
	}

	// save into the Terraform state.
	refreshBackupResourceData(getBackupResp, &data)

	diags = resp.State.Set(ctx, &data)
	resp.Diagnostics.Append(diags...)
}

func (r backupResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var projectId, clusterId, backupId string
	resp.Diagnostics.Append(req.State.GetAttribute(ctx, path.Root("project_id"), &projectId)...)
	resp.Diagnostics.Append(req.State.GetAttribute(ctx, path.Root("cluster_id"), &clusterId)...)
	resp.Diagnostics.Append(req.State.GetAttribute(ctx, path.Root("id"), &backupId)...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "get backup resource")
	getBackupResp, err := r.provider.client.GetBackupById(projectId, clusterId, backupId)
	if err != nil {
		resp.Diagnostics.AddError("Read Error", fmt.Sprintf("Unable to call GetBackupById, got error: %s", err))
		return
	}

	var data backupResourceData
	data.ClusterId = clusterId
	data.ProjectId = projectId
	data.BackupId = types.String{Value: backupId}
	refreshBackupResourceData(getBackupResp, &data)

	diags := resp.State.Set(ctx, &data)
	resp.Diagnostics.Append(diags...)
}

func refreshBackupResourceData(resp *tidbcloud.GetBackupResp, data *backupResourceData) {
	data.Name = resp.Name
	data.BackupId = types.String{Value: resp.Id}
	data.Type = types.String{Value: resp.Type}
	data.Size = types.String{Value: resp.Size}
	data.Status = types.String{Value: resp.Status}
	data.CreateTimestamp = types.String{Value: resp.CreateTimestamp}
	data.Description = types.String{Value: resp.Description}
}

func (r backupResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	resp.Diagnostics.AddError("Unsupported", fmt.Sprintf("backup can't be updated"))
}

func (r backupResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data backupResourceData

	diags := req.State.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "delete backup resource")
	err := r.provider.client.DeleteBackupById(data.ProjectId, data.ClusterId, data.BackupId.Value)
	if err != nil {
		resp.Diagnostics.AddError("Delete Error", fmt.Sprintf("Unable to call DeleteBackupById, got error: %s", err))
		return
	}
}

func (r backupResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	idParts := strings.Split(req.ID, ",")

	if len(idParts) != 3 || idParts[0] == "" || idParts[1] == "" || idParts[2] == "" {
		resp.Diagnostics.AddError(
			"Unexpected Import Identifier",
			fmt.Sprintf("Expected import identifier with format: project_id,cluster_id,backup_id. Got: %q", req.ID),
		)
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("project_id"), idParts[0])...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("cluster_id"), idParts[1])...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), idParts[2])...)
}
