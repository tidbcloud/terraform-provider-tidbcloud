package provider

import (
	"context"
	"fmt"
	"strings"

	backupApi "github.com/c4pt0r/go-tidbcloud-sdk-v1/client/backup"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

type backupResourceData struct {
	ClusterId       string       `tfsdk:"cluster_id"`
	ProjectId       string       `tfsdk:"project_id"`
	Name            string       `tfsdk:"name"`
	Description     types.String `tfsdk:"description"`
	BackupId        types.String `tfsdk:"id"`
	Type            types.String `tfsdk:"type"`
	Size            types.String `tfsdk:"size"`
	Status          types.String `tfsdk:"status"`
	CreateTimestamp types.String `tfsdk:"create_timestamp"`
}

// Ensure provider defined types fully satisfy framework interfaces
var _ resource.Resource = &backupResource{}
var _ resource.ResourceWithImportState = &backupResource{}

type backupResource struct {
	provider *tidbcloudProvider
}

func NewBackupResource() resource.Resource {
	return &backupResource{}
}

func (r *backupResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_backup"
}

func (r *backupResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	var ok bool
	if r.provider, ok = req.ProviderData.(*tidbcloudProvider); !ok {
		resp.Diagnostics.AddError("Internal provider error",
			fmt.Sprintf("Error in Configure: expected %T but got %T", tidbcloudProvider{}, req.ProviderData))
	}
}

func (r *backupResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "backup resource",
		Attributes: map[string]schema.Attribute{
			"project_id": schema.StringAttribute{
				MarkdownDescription: "The ID of the project. You can get the project ID from [tidbcloud_projects datasource](../data-sources/projects.md).",
				Required:            true,
			},
			"cluster_id": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "The ID of your cluster that you want to take a manual backup.",
			},
			"name": schema.StringAttribute{
				MarkdownDescription: "Specify the name for a manual backup. It is recommended that you use a unique name, so that it is easy to distinguish the backup when you query the backups.",
				Required:            true,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "The description of the backup. It helps you add additional information to the backup. Allows up to 256 characters.",
				Optional:            true,
				Computed:            true,
			},
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "The ID of the backup. It is generated by TiDB Cloud.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"type": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Enum: MANUAL/AUTO.The type of backup. TiDB Cloud only supports manual and auto backup. For more information, see [TiDB Cloud Documentation](https://docs.pingcap.com/tidbcloud/backup-and-restore#backup).",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"size": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "The bytes of the backup.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"status": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Enum: PENDING/RUNNING/FAILED/SUCCESS.The status of backup.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"create_timestamp": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "The creation time of the backup in UTC. The time format follows the ISO8601 standard, which is YYYY-MM-DD (year-month-day) + T +HH:MM:SS (hour-minutes-seconds) + Z. For example, 2020-01-01T00:00:00Z.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
	}
}

func (r *backupResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data backupResourceData
	diags := req.Config.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "created backup resource")
	createBackupBody := backupApi.CreateBackupBody{
		Name: &data.Name,
	}
	if !data.Description.IsUnknown() && !data.Description.IsNull() {
		description := data.Description.ValueString()
		createBackupBody.Description = &description
	}
	createBackupOK, err := r.provider.client.CreateBackup(backupApi.NewCreateBackupParams().WithProjectID(data.ProjectId).WithClusterID(data.ClusterId).WithBody(createBackupBody))
	if err != nil {
		resp.Diagnostics.AddError("Create Error", fmt.Sprintf("Unable to call create backup, got error: %s", err))
		return
	}

	tflog.Trace(ctx, "get backup resource")
	getBackupOfClusterOK, err := r.provider.client.GetBackupOfCluster(backupApi.NewGetBackupOfClusterParams().WithProjectID(data.ProjectId).WithClusterID(data.ClusterId).WithBackupID(createBackupOK.Payload.ID))
	if err != nil {
		resp.Diagnostics.AddError("Create Error", fmt.Sprintf("Unable to call GetBackupById, got error: %s", err))
		return
	}

	// save into the Terraform state.
	refreshBackupResourceData(getBackupOfClusterOK.Payload, &data)

	diags = resp.State.Set(ctx, &data)
	resp.Diagnostics.Append(diags...)
}

func (r backupResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var projectId, clusterId, backupId string
	resp.Diagnostics.Append(req.State.GetAttribute(ctx, path.Root("project_id"), &projectId)...)
	resp.Diagnostics.Append(req.State.GetAttribute(ctx, path.Root("cluster_id"), &clusterId)...)
	resp.Diagnostics.Append(req.State.GetAttribute(ctx, path.Root("id"), &backupId)...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "get backup resource")
	getBackupOfClusterOK, err := r.provider.client.GetBackupOfCluster(backupApi.NewGetBackupOfClusterParams().WithProjectID(projectId).WithClusterID(clusterId).WithBackupID(backupId))
	if err != nil {
		resp.Diagnostics.AddError("Read Error", fmt.Sprintf("Unable to call GetBackupById, got error: %s", err))
		return
	}

	var data backupResourceData
	data.ClusterId = clusterId
	data.ProjectId = projectId
	data.BackupId = types.StringValue(backupId)
	refreshBackupResourceData(getBackupOfClusterOK.Payload, &data)

	diags := resp.State.Set(ctx, &data)
	resp.Diagnostics.Append(diags...)
}

func refreshBackupResourceData(resp *backupApi.GetBackupOfClusterOKBody, data *backupResourceData) {
	data.Name = resp.Name
	data.BackupId = types.StringValue(resp.ID)
	data.Type = types.StringValue(resp.Type)
	data.Size = types.StringValue(resp.Size)
	data.Status = types.StringValue(resp.Status)
	data.CreateTimestamp = types.StringValue(resp.CreateTimestamp.String())
	data.Description = types.StringValue(resp.Description)
}

func (r *backupResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	resp.Diagnostics.AddError("Unsupported", fmt.Sprintf("backup can't be updated"))
}

func (r *backupResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data backupResourceData

	diags := req.State.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Trace(ctx, "delete backup resource")
	_, err := r.provider.client.DeleteBackup(backupApi.NewDeleteBackupParams().WithProjectID(data.ProjectId).WithClusterID(data.ClusterId).WithBackupID(data.BackupId.ValueString()))
	if err != nil {
		resp.Diagnostics.AddError("Delete Error", fmt.Sprintf("Unable to call DeleteBackupById, got error: %s", err))
		return
	}
}

func (r *backupResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	idParts := strings.Split(req.ID, ",")

	if len(idParts) != 3 || idParts[0] == "" || idParts[1] == "" || idParts[2] == "" {
		resp.Diagnostics.AddError(
			"Unexpected Import Identifier",
			fmt.Sprintf("Expected import identifier with format: project_id,cluster_id,backup_id. Got: %q", req.ID),
		)
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("project_id"), idParts[0])...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("cluster_id"), idParts[1])...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), idParts[2])...)
}
